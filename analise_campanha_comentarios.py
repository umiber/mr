# -*- coding: utf-8 -*-
"""analise_campanha_comentarios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15KNt6A2mzSJjfdw5Jgt0sVOh8cncQ3QM

# üìò An√°lise de Campanhas com Coment√°rios
"""



# üîº 1. Upload da planilha Excel
from google.colab import files
uploaded = files.upload()

# üì• 2. Leitura da planilha e das abas
import pandas as pd

file_name = list(uploaded.keys())[0]
xls = pd.ExcelFile(file_name)

df_campanha = pd.read_excel(xls, "Campanha")
df_post = pd.read_excel(xls, "Post")

print("‚úÖ Dados carregados com sucesso!")
print(f"‚ñ∂ Campanha: {df_campanha.shape[0]} linhas")
print(f"‚ñ∂ Post: {df_post.shape[0]} linhas")

# üëÄ 3. Visualiza√ß√£o inicial dos dados
display(df_campanha.head())
display(df_post.head())

# üí¨ 4. An√°lise de coment√°rios e sentimentos
!pip install -q transformers
from transformers import pipeline

# Cria pipeline de sentimento
sentiment_analyzer = pipeline("sentiment-analysis", model="distilbert/distilbert-base-uncased-finetuned-sst-2-english")

# Aplica an√°lise nos primeiros 100 coment√°rios (por performance)
comentarios = df_post["Coment√°rio"].dropna().astype(str).tolist()[:100]
sentimentos = sentiment_analyzer(comentarios)

# Cria DataFrame com resultados
import pandas as pd
df_sentimento = pd.DataFrame(sentimentos)
df_sentimento["Coment√°rio"] = comentarios

# Exibe resultados
df_sentimento.head(10)

# 5. Bloco complementar: Gr√°fico de barras da distribui√ß√£o de sentimentos

import matplotlib.pyplot as plt
import seaborn as sns
from mpl_toolkits.mplot3d import Axes3D
import numpy as np


# Converte para DataFrame a coluna de sentimentos
df_post["Sentimento"] = [s["label"].capitalize() for s in sentimentos]

# Conta quantos coment√°rios para cada sentimento
sent_counts = df_post["Sentimento"].value_counts().reset_index()
sent_counts.columns = ["Sentimento", "Quantidade"]

# Gr√°fico
# Coordenadas
x = np.arange(len(sent_counts))
y = np.zeros_like(x)
z = np.zeros_like(x)
dx = np.ones_like(x) * 0.5
dy = np.ones_like(x) * 0.5
dz = sent_counts["Quantidade"].values

# Cria√ß√£o da figura
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')

# Barras 3D
bars = ax.bar3d(x, y, z, dx, dy, dz, color='royalblue', alpha=0.8)

# R√≥tulos e layout
ax.set_xticks(x)
ax.set_xticklabels(sent_counts["Sentimento"])
ax.set_xlabel('Sentimento')
ax.set_ylabel('')
ax.set_zlabel('Quantidade')
ax.set_title('üìä Distribui√ß√£o de Sentimentos nos Coment√°rios (3D)')

# Adiciona r√≥tulo com valor no topo de cada barra
for i in range(len(dz)):
    ax.text(x[i], y[i], dz[i] + 0.5, str(dz[i]), ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

# 6. Gera√ß√£o de s√≠ntese dos coment√°rios em ingl√™s com transformers
!pip install -q transformers sentencepiece
from transformers import pipeline

# Carrega o modelo de sumariza√ß√£o
resumidor = pipeline("summarization", model="facebook/bart-large-cnn")

# Junta os coment√°rios em um √∫nico texto
comentarios = df_post["Coment√°rio"].dropna().astype(str).tolist()
texto_unico = " ".join(comentarios)

# Divide o texto em blocos menores (~500 caracteres por bloco)
blocos = []
tamanho_bloco = 500
for i in range(0, len(texto_unico), tamanho_bloco):
    blocos.append(texto_unico[i:i + tamanho_bloco])

# Gera resumos parciais
resumos_parciais = []
for i, bloco in enumerate(blocos):
    try:
        resumo = resumidor(bloco, max_length=100, min_length=30, do_sample=False)[0]['summary_text']
        resumos_parciais.append(resumo)
    except Exception as e:
        print(f"Erro ao resumir bloco {i}: {e}")

# Junta os resumos parciais e gera uma s√≠ntese final
texto_resumo_parcial = " ".join(resumos_parciais)
sintese_final = resumidor(texto_resumo_parcial, max_length=130, min_length=30, do_sample=False)[0]['summary_text']

# Exibe o resultado em HTML com quebra de linha
from IPython.display import display, HTML

display(HTML(f"""
<div style='background-color:#f9f9f9; border:1px solid #ccc; padding:20px; border-radius:5px; font-family:Arial; line-height:1.6; max-width:1000px;'>
<strong>üìò Insight baseado nos coment√°rios:</strong><br><br>
{sintese_final}
</div>
"""))

# üìä 7. Gr√°ficos por Sexo, Idade, Likes
import seaborn as sns
import matplotlib.pyplot as plt

# Distribui√ß√£o de sexo
sns.countplot(data=df_post, x="Sexo")
plt.title("Distribui√ß√£o por Sexo")
plt.show()

# Likes por sexo
sns.boxplot(data=df_post, x="Sexo", y="Likes")
plt.title("Likes por Sexo")
plt.show()

# Likes por faixa et√°ria (binned)
df_post["FaixaEtaria"] = pd.cut(df_post["Idade"], bins=[0, 20, 30, 40, 50, 100], labels=["<20", "21‚Äì30", "31‚Äì40", "41‚Äì50", "50+"])
sns.boxplot(data=df_post, x="FaixaEtaria", y="Likes")
plt.title("Likes por Faixa Et√°ria")
plt.show()

import os
import ipywidgets as widgets
from IPython.display import display, clear_output

def export_to_pdf(btn):
    clear_output()
    print("üìù Gerando PDF...")
    os.system("jupyter nbconvert --to pdf analise_campanha_comentarios.ipynb")
    print("‚úÖ PDF gerado com sucesso!")

button = widgets.Button(description="üìÑ Gerar PDF da an√°lise")
button.on_click(export_to_pdf)
display(button)